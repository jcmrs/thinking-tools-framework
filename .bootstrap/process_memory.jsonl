{"id": "pm-001", "type": "StrategicDecision", "title": "YAML Specification Format", "summary": "Selected YAML over JSON, TOML, and Python DSL for thinking tool specifications", "rationale": "Human readability and accessibility for non-programmers. YAML provides comments, multi-line strings, and familiar infrastructure pattern. Balances expressiveness with simplicity.", "source_adr": "ADR-001", "related_concepts": ["accessibility", "declarative-design", "human-friendly"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-005", "pm-007"], "tags": ["format", "yaml", "specification", "accessibility"]}
{"id": "pm-002", "type": "StrategicDecision", "title": "Sandboxed Jinja2 Template Engine", "summary": "Use Jinja2 with custom sandboxed environment for template rendering", "rationale": "Balance between power and security. Jinja2 is battle-tested, familiar, and provides rich features. Sandboxing prevents arbitrary code execution while preserving needed functionality (conditionals, loops, filters).", "source_adr": "ADR-002", "related_concepts": ["security", "templates", "sandboxing", "defense-in-depth"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-019"], "tags": ["template-engine", "security", "jinja2", "sandboxing"]}
{"id": "pm-003", "type": "StrategicDecision", "title": "Append-Only Process Memory Log", "summary": "Use JSONL append-only log with deprecation instead of deletion", "rationale": "Never lose information - critical for AI-First principle. Deprecate entries instead of deleting to preserve context and decision history. JSONL format enables efficient append and streaming read.", "source_adr": "ADR-003", "related_concepts": ["ai-first", "context-preservation", "immutability"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-025"], "tags": ["process-memory", "jsonl", "immutability", "ai-first"]}
{"id": "pm-004", "type": "StrategicDecision", "title": "Hot-Reload Capability", "summary": "Support spec changes without restart via file watching and atomic swap", "rationale": "Developer experience and iteration speed. Sub-second feedback loops enable rapid experimentation. File watcher detects changes, validates, and atomically swaps in new specs without disrupting running system.", "source_adr": "ADR-004", "related_concepts": ["automation", "developer-experience", "iteration-speed"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-006"], "tags": ["hot-reload", "developer-experience", "automation"]}
{"id": "pm-005", "type": "StrategicDecision", "title": "Multi-Layer Validation Pipeline", "summary": "Implement three sequential validation layers: schema, semantic, security", "rationale": "Defense-in-depth for specification quality. Schema catches structure errors, semantic catches logic errors, security catches dangerous patterns. Each layer adds context to errors for developer guidance.", "source_adr": "ADR-005", "related_concepts": ["validation", "quality-assurance", "defense-in-depth"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-001", "pm-002"], "tags": ["validation", "quality", "security", "multi-layer"]}
{"id": "pm-006", "type": "StrategicDecision", "title": "Protocol-Based Plugin Architecture", "summary": "Use Python Protocols (PEP 544) for structural subtyping with entry point discovery", "rationale": "Extensibility without coupling. Plugins discovered via entry points, validated via protocol conformance. No core changes needed for new plugins. Modularity and extensibility cornerstones embodied.", "source_adr": "ADR-006", "related_concepts": ["extensibility", "modularity", "plugins", "protocols"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-004"], "tags": ["plugins", "protocols", "extensibility", "modularity"]}
{"id": "pm-007", "type": "StrategicDecision", "title": "Semantic Versioning for Specifications", "summary": "Use SemVer (MAJOR.MINOR.PATCH) for spec versions with clear breaking change policy", "rationale": "Predictable evolution and backward compatibility. MAJOR for breaking changes, MINOR for features, PATCH for fixes. Enables gradual migration and clear expectations for spec consumers.", "source_adr": "ADR-007", "related_concepts": ["versioning", "backward-compatibility", "evolution"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-001"], "tags": ["versioning", "semver", "compatibility"]}
{"id": "pm-008", "type": "StrategicDecision", "title": "Five-Layer Architecture", "summary": "Organize system into UI, Orchestration, Processing, Storage, Integration layers", "rationale": "Clear separation of concerns enables independent evolution. Each layer has single responsibility. Dependency direction enforced (higher layers depend on lower). Modularity cornerstone embodied in architecture.", "source_adr": "ADR-008", "related_concepts": ["architecture", "modularity", "separation-of-concerns"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-006"], "tags": ["architecture", "layers", "modularity", "separation-of-concerns"]}
{"id": "pm-009", "type": "StrategicDecision", "title": "Zero Serena Core Modifications", "summary": "Integrate with Serena exclusively through MCP tool interface, no core changes", "rationale": "Stability and decoupling. Thinking tools remain independent. Serena updates don't break thinking tools. Integration cornerstone demonstrated through MCP protocol.", "source_adr": "ADR-009", "related_concepts": ["integration", "decoupling", "stability", "mcp"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-008"], "tags": ["integration", "serena", "mcp", "decoupling"]}
{"id": "pm-010", "type": "StrategicDecision", "title": "Declarative-First Design", "summary": "Favor declarative specifications over imperative code", "rationale": "Accessibility and automation. Non-programmers can create tools through YAML. Declarative specs enable code generation, validation, and analysis. Aligns with configurability and automation cornerstones.", "source_adr": "ADR-010", "related_concepts": ["declarative", "accessibility", "code-generation"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md", "session": "design-phase-2025-01"}, "links": ["pm-001", "pm-006"], "tags": ["declarative", "yaml", "code-generation", "accessibility"]}
{"id": "pm-011", "type": "AlternativeConsidered", "title": "JSON Format for Specifications", "summary": "Considered JSON as specification format instead of YAML", "rationale": "Rejected due to poor human readability, no comment support, and verbose multi-line strings. While JSON has strict parsing and excellent tooling, these benefits didn't outweigh usability costs for non-programmers.", "source_adr": "ADR-001", "related_concepts": ["format", "json", "tradeoffs"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md"}, "links": ["pm-001"], "tags": ["alternative", "json", "rejected"]}
{"id": "pm-012", "type": "AlternativeConsidered", "title": "TOML Format for Specifications", "summary": "Considered TOML as specification format", "rationale": "Rejected due to poor nested structure support and limited template capabilities. While TOML is simple and readable, it's less familiar to developers and doesn't handle deep nesting well.", "source_adr": "ADR-001", "related_concepts": ["format", "toml", "tradeoffs"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.8, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md"}, "links": ["pm-001"], "tags": ["alternative", "toml", "rejected"]}
{"id": "pm-013", "type": "AlternativeConsidered", "title": "Python DSL for Specifications", "summary": "Considered Python-based domain-specific language", "rationale": "Rejected despite maximum expressiveness due to accessibility barrier (requires Python knowledge) and security risks (arbitrary code execution). Violates accessibility goal and introduces attack surface.", "source_adr": "ADR-001", "related_concepts": ["dsl", "python", "security", "accessibility"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md"}, "links": ["pm-001", "pm-002"], "tags": ["alternative", "python-dsl", "rejected", "security"]}
{"id": "pm-014", "type": "AlternativeConsidered", "title": "String Format Template Engine", "summary": "Considered Python str.format() for templates", "rationale": "Rejected as too limited. While safe and simple, lacks conditionals and loops needed for complex thinking tools. Expressiveness requirement not met.", "source_adr": "ADR-002", "related_concepts": ["templates", "simplicity", "tradeoffs"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md"}, "links": ["pm-002"], "tags": ["alternative", "string-format", "rejected", "too-limited"]}
{"id": "pm-015", "type": "AlternativeConsidered", "title": "Mustache/Handlebars Template Engine", "summary": "Considered logic-less template engines", "rationale": "Rejected despite inherent security benefits. Too limited for complex conditional logic and loops needed in thinking tools. Security benefit doesn't outweigh capability loss.", "source_adr": "ADR-002", "related_concepts": ["templates", "logic-less", "security"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md"}, "links": ["pm-002"], "tags": ["alternative", "mustache", "rejected", "too-limited"]}
{"id": "pm-016", "type": "AlternativeConsidered", "title": "Custom Template Language", "summary": "Considered building custom template language", "rationale": "Rejected due to development cost and learning curve. While providing full security control, not worth reinventing wheel. No editor support and unfamiliar syntax would hurt adoption.", "source_adr": "ADR-002", "related_concepts": ["custom-language", "reinventing-wheel"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"author": "Thinking Tools Design Team", "document": "04-ARCHITECTURE-DECISION-RECORDS.md"}, "links": ["pm-002"], "tags": ["alternative", "custom-language", "rejected"]}
{"id": "pm-030", "type": "AlternativeConsidered", "title": "XML Specification Format", "summary": "Considered XML for specification format", "rationale": "Rejected due to verbosity and poor human readability. While widely supported and validated, XML syntax creates barriers to quick editing. YAML's clean syntax better for human-first authoring.", "source_adr": "ADR-001", "related_concepts": ["xml", "verbosity", "readability"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"source": "Format selection discussion", "session": "design-phase-2025-01"}, "links": ["pm-001"], "tags": ["alternative", "xml", "rejected", "verbose"]}
{"id": "pm-031", "type": "AlternativeConsidered", "title": "INI/CFG Configuration Format", "summary": "Considered INI-style configuration files", "rationale": "Rejected due to limited nesting and data type support. Cannot represent complex nested structures like parameters schema. Too primitive for rich metadata requirements.", "source_adr": "ADR-001", "related_concepts": ["ini", "cfg", "limited-structure"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Format selection discussion", "session": "design-phase-2025-01"}, "links": ["pm-001"], "tags": ["alternative", "ini", "rejected", "too-limited"]}
{"id": "pm-032", "type": "AlternativeConsidered", "title": "Pure Python Files for Specifications", "summary": "Considered Python files (.py) as specification format", "rationale": "Rejected due to security risks and barrier to non-programmers. Executing arbitrary Python opens massive attack surface. Requires Python knowledge to author. YAML declarative approach safer and more accessible.", "source_adr": "ADR-001", "related_concepts": ["python", "security", "accessibility"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"source": "Security design discussion", "session": "design-phase-2025-01"}, "links": ["pm-001", "pm-019"], "tags": ["alternative", "python", "rejected", "security-risk"]}
{"id": "pm-033", "type": "AlternativeConsidered", "title": "Database for Process Memory Storage", "summary": "Considered SQLite or other database for process memory", "rationale": "Rejected due to unnecessary complexity and dependency management. Database requires schema migrations, connection handling, transaction management. JSONL append-only file simpler, more portable, easier to backup and version control.", "source_adr": "ADR-003", "related_concepts": ["database", "sqlite", "complexity"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"source": "Process memory storage discussion", "session": "design-phase-2025-01"}, "links": ["pm-003"], "tags": ["alternative", "database", "rejected", "over-engineering"]}
{"id": "pm-034", "type": "AlternativeConsidered", "title": "Git-Based Process Memory", "summary": "Considered using git commits/tags for process memory entries", "rationale": "Rejected as too heavyweight and coupling to git. Not all projects use git. Commit history not designed for structured metadata queries. Searching/filtering would be inefficient. JSONL provides better query capabilities.", "source_adr": "ADR-003", "related_concepts": ["git", "version-control", "coupling"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.8, "phase": "product", "deprecated": false, "provenance": {"source": "Process memory storage discussion", "session": "design-phase-2025-01"}, "links": ["pm-003"], "tags": ["alternative", "git", "rejected", "heavyweight"]}
{"id": "pm-035", "type": "AlternativeConsidered", "title": "Inheritance-Based Plugin System", "summary": "Considered class inheritance for plugin architecture", "rationale": "Rejected due to tight coupling and fragile base class problem. Inheritance creates implicit dependencies. Changes to base class break all plugins. Protocol-based approach provides loose coupling and easier testing.", "source_adr": "ADR-006", "related_concepts": ["inheritance", "coupling", "fragile-base"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Plugin architecture discussion", "session": "design-phase-2025-01"}, "links": ["pm-006"], "tags": ["alternative", "inheritance", "rejected", "tight-coupling"]}
{"id": "pm-036", "type": "AlternativeConsidered", "title": "Dynamic Imports for Plugin Discovery", "summary": "Considered Python's __import__ or importlib for dynamic plugin loading", "rationale": "Rejected due to implicit dependencies and hard-to-trace errors. Dynamic imports hide dependencies from type checkers and IDEs. Errors only surface at runtime. Explicit protocol registration provides better discoverability.", "source_adr": "ADR-006", "related_concepts": ["dynamic-import", "implicit-dependencies"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"source": "Plugin architecture discussion", "session": "design-phase-2025-01"}, "links": ["pm-006"], "tags": ["alternative", "dynamic-import", "rejected", "implicit"]}
{"id": "pm-037", "type": "AlternativeConsidered", "title": "React/Vue UI Framework", "summary": "Considered rich JavaScript UI framework for thinking tools interface", "rationale": "Rejected as scope creep and against Terminal-First principle. Thinking tools should integrate with existing Claude Code UI, not replace it. Adding web UI would require bundling, state management, API layer - massive complexity increase.", "source_adr": "ADR-008", "related_concepts": ["react", "vue", "scope-creep", "terminal-first"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Architecture scope discussion", "session": "design-phase-2025-01"}, "links": ["pm-008", "pm-009"], "tags": ["alternative", "ui-framework", "rejected", "scope-creep"]}
{"id": "pm-038", "type": "AlternativeConsidered", "title": "REST API for Serena Integration", "summary": "Considered HTTP REST API as integration method", "rationale": "Rejected in favor of MCP protocol. REST would require HTTP server, port management, authentication. MCP provides standardized protocol specifically designed for AI tool integration. REST would be reinventing what MCP already provides.", "source_adr": "ADR-009", "related_concepts": ["rest-api", "http", "mcp"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"source": "Integration method selection", "session": "design-phase-2025-01"}, "links": ["pm-009"], "tags": ["alternative", "rest", "rejected", "mcp-better"]}
{"id": "pm-039", "type": "AlternativeConsidered", "title": "Monolithic Architecture", "summary": "Considered single-module monolithic implementation", "rationale": "Rejected in favor of five-layer architecture. Monolith would violate Modularity cornerstone. Harder to test, extend, and understand. Layered architecture provides clear separation of concerns and enables independent evolution of layers.", "source_adr": "ADR-008", "related_concepts": ["monolith", "modularity", "architecture"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Architecture design", "session": "design-phase-2025-01"}, "links": ["pm-008"], "tags": ["alternative", "monolith", "rejected", "against-modularity"]}
{"id": "pm-040", "type": "AlternativeConsidered", "title": "Markdown Template Format", "summary": "Considered using Markdown files with front-matter as template format", "rationale": "Partially adopted - templates are Markdown, but specifications remain YAML. Considered pure Markdown specs with YAML front-matter, but rejected because metadata (parameters schema, etc.) would dominate front-matter. YAML better for structured metadata, Markdown better for template content.", "source_adr": "ADR-001", "related_concepts": ["markdown", "front-matter", "hybrid-approach"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.8, "phase": "product", "deprecated": false, "provenance": {"source": "Format selection discussion", "session": "design-phase-2025-01"}, "links": ["pm-001", "pm-010"], "tags": ["alternative", "markdown", "partially-adopted"]}
{"id": "pm-041", "type": "AlternativeConsidered", "title": "GraphQL API for Integration", "summary": "Considered GraphQL instead of MCP for Serena integration", "rationale": "Rejected because MCP is purpose-built for AI tool integration while GraphQL is general-purpose. GraphQL would require schema definition, resolver implementation, and client generation. MCP provides simpler request/response model optimized for AI agents.", "source_adr": "ADR-009", "related_concepts": ["graphql", "mcp", "api-design"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"source": "Integration method selection", "session": "design-phase-2025-01"}, "links": ["pm-009"], "tags": ["alternative", "graphql", "rejected", "over-engineering"]}
{"id": "pm-017", "type": "LessonLearned", "title": "Modularity Enables JIT Learning", "summary": "Breaking system into independent modules enables just-in-time learning for AI agents", "rationale": "Discovered that Claude Code instances can load module-specific context on demand rather than reading entire system. Memory summaries (150-200 words) plus full specs on demand achieves 70% token savings. Modularity cornerstone directly enables AI-First principle.", "source_adr": null, "related_concepts": ["modularity", "ai-first", "jit-learning", "token-efficiency"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"source": "JIT reading system design", "session": "memory-provisioning-phase"}, "links": ["pm-008", "pm-003"], "tags": ["lesson", "modularity", "ai-first", "token-efficiency"]}
{"id": "pm-018", "type": "LessonLearned", "title": "AI-First Requires Explicit Imperative Integration", "summary": "AI-First principles must be explicitly integrated into all specifications, not assumed", "rationale": "Initially assumed AI-First would emerge naturally. Learned it requires deliberate design: machine-readable contracts (JSON schemas), self-documenting code (inline metadata), context preservation (process memory), no hidden state (everything queryable). Created ADR-000 to codify this learning.", "source_adr": "ADR-000", "related_concepts": ["ai-first", "explicit-design", "imperatives"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Imperative integration realization", "session": "specification-writing-phase"}, "links": ["pm-010"], "tags": ["lesson", "ai-first", "explicit-design"]}
{"id": "pm-019", "type": "LessonLearned", "title": "Template Injection is Primary Security Risk", "summary": "In declarative systems with templates, template injection becomes the main attack surface", "rationale": "Learned that moving logic from code to templates shifts security focus. Template injection (inserting malicious template code) becomes primary risk. Requires sandboxing, input validation, and careful filter/tag whitelisting. Security must be designed into template engine, not added later.", "source_adr": "ADR-002", "related_concepts": ["security", "template-injection", "defense-in-depth"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Security analysis during ADR-002", "session": "design-phase-2025-01"}, "links": ["pm-002", "pm-005"], "tags": ["lesson", "security", "template-injection"]}
{"id": "pm-020", "type": "LessonLearned", "title": "Process Memory is Critical for Handovers", "summary": "Without process memory, AI session transitions lose critical context and rationale", "rationale": "Observed that new Claude instances struggled to understand 'why' decisions were made when only given 'what' was decided. Process memory capturing rationale, alternatives, and confidence enables effective handovers. Created session_handover.yml thinking tool to operationalize this.", "source_adr": "ADR-003", "related_concepts": ["process-memory", "context-preservation", "handovers"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"source": "Session handover experiments", "session": "design-phase-2025-01"}, "links": ["pm-003"], "tags": ["lesson", "process-memory", "handovers", "ai-first"]}
{"id": "pm-021", "type": "LessonLearned", "title": "Five Cornerstones Must Be Measurable", "summary": "Abstract principles need concrete manifestations to be useful in code review", "rationale": "Realized Five Cornerstones (Configurability, Modularity, Extensibility, Integration, Automation) were too abstract for practical assessment. Created code_review_checklist.yml with specific, checkable criteria for each cornerstone. Principles become actionable through checklists.", "source_adr": null, "related_concepts": ["five-cornerstones", "measurability", "code-review"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "development", "deprecated": false, "provenance": {"source": "Example thinking tool creation", "session": "phase1-examples-creation"}, "links": ["pm-004", "pm-006"], "tags": ["lesson", "five-cornerstones", "measurability"]}
{"id": "pm-042", "type": "LessonLearned", "title": "Progressive Depth Reduces Tool Explosion", "summary": "Single tool with depth parameters better than multiple similar tools", "rationale": "Discovered while creating examples. Could have created separate tools for quick_think, deep_think, etc. Instead, unified under think_aloud with depth parameter. Reduces tool count, easier to discover, single interface to learn. Trade-off: slightly more complex parameter handling.", "source_adr": null, "related_concepts": ["parameters", "modularity", "user-experience"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "development", "deprecated": false, "provenance": {"source": "Phase 1 example tool creation", "session": "bootstrap-phase1-2025-01-15"}, "links": ["pm-boot-002"], "tags": ["lesson", "progressive-depth", "design-pattern"]}
{"id": "pm-043", "type": "LessonLearned", "title": "Context Preservation Enables Session Continuity", "summary": "Explicit handover tools critical for AI session transitions", "rationale": "During session_handover.yml creation, realized AI agents lack implicit memory across sessions. Without structured handover, new AI instance starts from zero. Lesson: AI-First principle means designing for stateless agents with explicit context. Handover tools are infrastructure, not nice-to-have.", "source_adr": null, "related_concepts": ["ai-first", "context-preservation", "session-continuity"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "development", "deprecated": false, "provenance": {"source": "Session handover tool development", "session": "bootstrap-phase1-2025-01-15"}, "links": ["pm-020", "pm-boot-001"], "tags": ["lesson", "ai-first", "handover"]}
{"id": "pm-044", "type": "LessonLearned", "title": "Checkpoints After Each Phase Prevent Information Loss", "summary": "Comprehensive checkpoint documents enable resumption at any phase boundary", "rationale": "Bootstrap planned with 4 phases and auto-compact risk. Created detailed checkpoint documents (PHASE1-EXAMPLES-COMPLETE.md, etc.) with context, decisions, resumption instructions. When context window compacts, can resume seamlessly. Lesson: Design for interruption from the start.", "source_adr": null, "related_concepts": ["context-preservation", "checkpoints", "resilience"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "development", "deprecated": false, "provenance": {"source": "Bootstrap planning and execution", "session": "bootstrap-2025-01-15"}, "links": ["pm-020", "pm-043"], "tags": ["lesson", "checkpoints", "bootstrap"]}
{"id": "pm-045", "type": "LessonLearned", "title": "Domain-Specific Branching Better Than Tool Proliferation", "summary": "Conditional template sections avoid creating separate tools for each domain", "rationale": "Error analysis could have been 7 different tools (runtime_error, logic_error, etc.). Instead, single tool with error_type parameter and conditional Jinja2 sections. Provides unified structure while allowing specialization. Lesson: Parameters + conditionals > separate tools.", "source_adr": null, "related_concepts": ["parameters", "conditionals", "tool-design"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "development", "deprecated": false, "provenance": {"source": "Error analysis tool development", "session": "bootstrap-phase1-2025-01-15"}, "links": ["pm-042", "pm-boot-002"], "tags": ["lesson", "domain-branching", "design-pattern"]}
{"id": "pm-046", "type": "LessonLearned", "title": "Examples Must Embody Principles, Not Just Demonstrate Syntax", "summary": "Example tools should showcase framework philosophy, not just technical capabilities", "rationale": "Could have created minimal examples showing YAML structure. Instead, created production-quality tools that embody Five Cornerstones and AI-First principles. Code review checklist explicitly validates cornerstones. Session handover demonstrates zero-info-loss. Lesson: Examples are teaching tools for philosophy, not just syntax.", "source_adr": null, "related_concepts": ["examples", "philosophy", "teaching"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "development", "deprecated": false, "provenance": {"source": "Example tool design decisions", "session": "bootstrap-phase1-2025-01-15"}, "links": ["pm-boot-001", "pm-boot-003"], "tags": ["lesson", "examples", "philosophy"]}
{"id": "pm-022", "type": "AssumptionMade", "title": "Spec Format Won't Need Frequent Major Changes", "summary": "Assumed specification schema will be stable after v1.0", "rationale": "Betting that initial design captures core needs and future changes will be additive (MINOR/PATCH) rather than breaking (MAJOR). Semantic versioning provides migration path if assumption proves wrong. Confidence based on thorough upfront design.", "source_adr": "ADR-007", "related_concepts": ["versioning", "stability", "evolution"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.75, "phase": "product", "deprecated": false, "provenance": {"source": "Versioning strategy discussion", "session": "design-phase-2025-01"}, "links": ["pm-007"], "tags": ["assumption", "versioning", "stability"]}
{"id": "pm-023", "type": "AssumptionMade", "title": "Most Users Can Write YAML but Not Python", "summary": "Assumed target users comfortable with YAML but not programming", "rationale": "Betting on infrastructure-as-code familiarity (Kubernetes, Docker Compose, CI/CD configs) being more widespread than Python programming. If wrong, Python DSL alternative remains viable future option. YAML accessibility enables broader adoption.", "source_adr": "ADR-001", "related_concepts": ["accessibility", "target-audience", "yaml"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.8, "phase": "product", "deprecated": false, "provenance": {"source": "Target audience analysis", "session": "design-phase-2025-01"}, "links": ["pm-001", "pm-013"], "tags": ["assumption", "audience", "accessibility"]}
{"id": "pm-024", "type": "AssumptionMade", "title": "Jinja2 Sandbox is Sufficient Security", "summary": "Assumed sandboxed Jinja2 provides adequate protection against template injection", "rationale": "Betting on battle-tested sandboxing approach (used in Ansible, etc.) combined with strict whitelisting. Aware of historical sandbox escapes but mitigated through: restricted feature set, input validation, resource limits, and regular security updates. Multi-layer validation provides defense-in-depth.", "source_adr": "ADR-002", "related_concepts": ["security", "sandboxing", "risk-acceptance"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"source": "Security analysis", "session": "design-phase-2025-01"}, "links": ["pm-002", "pm-019"], "tags": ["assumption", "security", "sandboxing"]}
{"id": "pm-025", "type": "AssumptionMade", "title": "Append-Only Log Won't Grow Too Large", "summary": "Assumed process memory log size manageable with periodic archival", "rationale": "Betting that process memory entries (hundreds to low thousands) won't create performance issues. JSONL streaming read enables efficient processing. Log rotation and archival strategies available if growth becomes problem. Monitoring log size validates assumption over time.", "source_adr": "ADR-003", "related_concepts": ["scalability", "performance", "process-memory"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.8, "phase": "product", "deprecated": false, "provenance": {"source": "Process memory design", "session": "design-phase-2025-01"}, "links": ["pm-003"], "tags": ["assumption", "scalability", "process-memory"]}
{"id": "pm-026", "type": "AssumptionMade", "title": "File Watching is Reliable Across Platforms", "summary": "Assumed file system watchers work reliably on Linux, macOS, Windows", "rationale": "Betting on mature file watching libraries (watchdog, inotify, etc.) being reliable across platforms. Aware of edge cases (network drives, Docker volumes) but acceptable for local development use case. Polling fallback available if watching fails.", "source_adr": "ADR-004", "related_concepts": ["hot-reload", "cross-platform", "reliability"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"source": "Hot-reload implementation discussion", "session": "design-phase-2025-01"}, "links": ["pm-004"], "tags": ["assumption", "file-watching", "cross-platform"]}
{"id": "pm-027", "type": "MentalModels", "title": "Five-Layer Architecture Mental Model", "summary": "Think of system as five stacked layers with clear boundaries and dependency rules", "rationale": "Layer 1 (UI) talks to Layer 2 (Orchestration), which talks to Layer 3 (Processing), which talks to Layer 4 (Storage). Layer 5 (Integration) integrates across all layers. Dependencies flow downward only. Each layer has single responsibility. Violating layer boundaries indicates architecture drift.", "source_adr": "ADR-008", "related_concepts": ["architecture", "layers", "mental-model", "separation-of-concerns"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Architecture design sessions", "session": "design-phase-2025-01"}, "links": ["pm-008"], "tags": ["mental-model", "architecture", "layers"]}
{"id": "pm-028", "type": "MentalModels", "title": "Protocol-Based Dependency Injection Model", "summary": "Think of components as protocol contracts, not concrete implementations", "rationale": "Components define what they need via protocols (interfaces), not what classes they depend on. Runtime injection provides concrete implementations. This mental model enables: testing (inject mocks), extensibility (inject plugins), modularity (swap implementations). Think 'depends on capability' not 'depends on class'.", "source_adr": "ADR-006", "related_concepts": ["protocols", "dependency-injection", "interfaces"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Plugin architecture design", "session": "design-phase-2025-01"}, "links": ["pm-006"], "tags": ["mental-model", "protocols", "dependency-injection"]}
{"id": "pm-029", "type": "MentalModels", "title": "Thinking Tool Lifecycle Model", "summary": "Think of thinking tool flow: Discover → Load → Validate → Render → Execute", "rationale": "Every thinking tool goes through lifecycle: (1) Discovered via directory scan, (2) Loaded and parsed from YAML, (3) Validated against schema/semantics/security, (4) Template rendered with parameters, (5) Result delivered to user. Understanding this flow helps debug issues and design new tools. Hot-reload inserts validation step before atomic swap.", "source_adr": "ADR-004", "related_concepts": ["lifecycle", "thinking-tools", "flow"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "product", "deprecated": false, "provenance": {"source": "System design documentation", "session": "design-phase-2025-01"}, "links": ["pm-004", "pm-005"], "tags": ["mental-model", "lifecycle", "thinking-tools"]}
{"id": "pm-boot-001", "type": "StrategicDecision", "title": "Example Tool Selection Strategy", "summary": "Selected 9 example tools across 4 categories: metacognition, review, handoff, debugging", "rationale": "Chose tools that: (1) span all major cognitive modes, (2) demonstrate schema capabilities, (3) provide immediate practical value, (4) embody Five Cornerstones and AI-First principles. Coverage more important than quantity. Each tool serves as template users can copy and modify.", "source_adr": null, "related_concepts": ["examples", "coverage", "demonstration"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "development", "deprecated": false, "provenance": {"source": "Phase 1 example tool creation", "session": "bootstrap-phase1-2025-01-15"}, "links": ["pm-001", "pm-010"], "tags": ["bootstrap", "examples", "tool-selection"]}
{"id": "pm-boot-002", "type": "LessonLearned", "title": "Progressive Depth Pattern Works Well", "summary": "Parameters enabling different thoroughness levels provide flexibility without tool explosion", "rationale": "Discovered pattern during example creation: single tool with depth/completeness parameters serves multiple use cases (quick/standard/detailed). Better than creating 3 separate tools. Examples: think_aloud (depth), session_handover (completeness), assumption_check (scope). Pattern reduces tool count while maintaining flexibility.", "source_adr": null, "related_concepts": ["design-patterns", "parameters", "flexibility"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "development", "deprecated": false, "provenance": {"source": "Phase 1 template design", "session": "bootstrap-phase1-2025-01-15"}, "links": ["pm-boot-001"], "tags": ["bootstrap", "lesson", "design-pattern", "progressive-depth"]}
{"id": "pm-boot-003", "type": "AssumptionMade", "title": "Code Review Should Explicitly Check Five Cornerstones", "summary": "Assumed code_review_checklist.yml should have explicit Five Cornerstones section", "rationale": "Decided to make principles actionable by providing checkable criteria for each cornerstone. Teaches users our values, ensures alignment, demonstrates principles in practice. Risk: might be too prescriptive for some users. Mitigation: tools are customizable.", "source_adr": null, "related_concepts": ["five-cornerstones", "code-review", "principles"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.85, "phase": "development", "deprecated": false, "provenance": {"source": "Phase 1 code review tool design", "session": "bootstrap-phase1-2025-01-15"}, "links": ["pm-021"], "tags": ["bootstrap", "assumption", "five-cornerstones"]}
{"id": "pm-047", "type": "Observation", "title": "Zero Serena Core Modifications Accelerates Adoption", "summary": "Observed that MCP integration enables thinking tools without changing Serena codebase", "rationale": "Critical observation during architecture design: By using MCP protocol, thinking tools can be added/removed without any changes to Serena core. This means: (1) No risk to Serena stability, (2) No coordination with Serena maintainers, (3) Users can install thinking tools independently. Validates ADR-009 decision.", "source_adr": "ADR-009", "related_concepts": ["mcp", "integration", "zero-modification"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.95, "phase": "product", "deprecated": false, "provenance": {"source": "MCP integration design", "session": "design-phase-2025-01"}, "links": ["pm-009"], "tags": ["observation", "mcp", "architecture", "adoption"]}
{"id": "pm-048", "type": "Constraint", "title": "Jinja2 Template Sandboxing Limits Available Features", "summary": "Security constraints restrict which Jinja2 features can be safely exposed", "rationale": "Cannot allow: file system access, subprocess execution, arbitrary imports, eval/exec. Must restrict to: safe filters, whitelisted functions, template inheritance (validated), variable interpolation. This constraint shapes tool capabilities - some advanced use cases impossible for security.", "source_adr": "ADR-002", "related_concepts": ["security", "sandboxing", "trade-offs"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "product", "deprecated": false, "provenance": {"source": "Security design constraints", "session": "design-phase-2025-01"}, "links": ["pm-002", "pm-019", "pm-024"], "tags": ["constraint", "security", "jinja2"]}
{"id": "pm-049", "type": "Observation", "title": "Example Tool Quality Directly Impacts Framework Adoption", "summary": "Observed during Phase 1: Examples teach philosophy more than documentation", "rationale": "Users learn by copying examples more than reading specs. High-quality examples (like code_review_checklist.yml with Five Cornerstones section) teach both syntax AND philosophy. Low-quality examples would teach wrong patterns. Observation: Examples are primary teaching mechanism, not secondary.", "source_adr": null, "related_concepts": ["examples", "adoption", "teaching"], "timestamp_created": "2025-11-15T23:45:08.096772", "confidence_level": 0.9, "phase": "development", "deprecated": false, "provenance": {"source": "Phase 1 example creation reflection", "session": "bootstrap-phase1-2025-01-15"}, "links": ["pm-boot-001", "pm-046"], "tags": ["observation", "examples", "adoption", "teaching"]}
{"id":"PM-021","title":"Import Hygiene and Module Structure","type":"lessons_learned","summary":"Mypy warnings about 'source file found twice' are architectural red flags when global state is involved. Missing __init__.py in src layout causes namespace ambiguity leading to duplicate module imports. Always add __init__.py to src/package/ and configure mypy with explicit_package_bases=true and mypy_path='src'.","rationale":"Non-technical user's pattern recognition about MCP event loop conflicts prevented critical production bug. Type checker warnings deserve investigation, not dismissal. Global state (mcp instance, registries, executors) + duplicate imports = catastrophic failures (event loop conflicts, state divergence, race conditions).","alternatives_considered":["Skip mypy (REJECTED - ignores architectural issue)","Singleton enforcement pattern (UNNECESSARY - proper package structure prevents duplicates)","Restructure to entry point script (OVERKILL - __init__.py fix is sufficient)"],"decision":"Add src/cogito/__init__.py to make cogito proper package + configure mypy with explicit_package_bases=true, namespace_packages=true, mypy_path='src'. Updated __main__.py to use FastMCP's mcp.run() instead of old MCP SDK patterns.","confidence":"high","tags":["python","imports","mypy","module-structure","global-state","MCP","fastmcp","src-layout"],"related_concepts":["namespace packages","import system","type checking","event loops","singleton pattern"],"links":["PM-004","PM-017","PM-008"],"created":"2025-11-17T18:00:00Z"}
